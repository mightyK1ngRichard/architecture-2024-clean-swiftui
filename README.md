# Clean SwiftUI

Clean SwiftUI — это архитектурный подход для разработки приложений на основе SwiftUI, вдохновленный принципами Clean Architecture. В данном репозитории представлена моя реализация этой архитектуры с учётом особенностей SwiftUI и современных подходов разработки.

## Особенности

### Поток данных

Архитектура организована следующим образом:
1.	View — отвечает за отображение интерфейса и взаимодействие с пользователем. Обменивается данными через ViewModel.
2.	ViewModel — промежуточный слой, который преобразует данные для Interactor и принимает подготовленные данные из Presenter для отображения на View.
3.	Interactor — слой бизнес-логики, где происходит обработка запросов и вызовы в WebRepository для работы с сетью или другими источниками данных.
4.	Presenter — отвечает за подготовку данных для ViewModel в удобном для отображения виде.
5.	Обратный поток: Presenter → ViewModel → View — это обеспечивает обновление интерфейса с учётом изменений данных.

### Использование протоколов
Для упрощения зависимости между слоями и повышения тестируемости используются протоколы:

#### Первая реализация(См. Stream/Snippets):
-	DisplayLogic — определяет взаимодействие Presenter и ViewModel.
-	BusinessLogic — определяет взаимодействие ViewModel и Interactor.
-	PresentationLogic — определяет взаимодействие Interactor и Presenter.

#### Вторая реализация(См. Stream/Profile):
```swift
// MARK: - ViewModel
protocol ViewDisplayLogic: ViewDisplayLogicOutput {}
protocol ViewDisplayLogicInput: AnyObject {}
protocol ViewDisplayLogicOutput: AnyObject {}
// MARK: - Input
protocol ViewInteractorInput: AnyObject {}
// MARK: - Presenter
protocol ProfilePresenterInput: AnyObject {}
```

### Работа с сетью
Для обработки сетевых запросов в Interactor используется WebRepository, который обеспечивает централизованную работу с API.

### Тестирование
Весь код покрыт unit тестами, что гарантирует стабильность и корректность работы приложения. Каждый слой можно тестировать изолированно благодаря использованию протоколов.

### Преимущества
-	Чёткое разделение обязанностей между слоями.
-	Повышенная читаемость и поддерживаемость кода.
-	Простота модульного тестирования.	Гибкость благодаря слабой связности между компонентами.

### Как использовать
1.	View — создаёт пользовательский интерфейс и отправляет действия пользователя в ViewModel.
2.	ViewModel — передаёт запросы в Interactor, обновляет состояние View.
3.	Interactor — вызывает WebRepository для сетевых запросов, обрабатывает логику, передаёт данные в Presenter.
4.	Presenter — возвращает подготовленные данные для ViewModel.
